Mongodb
Relational operators
Logical operators
between 1000 and 5000 -- comma 
$exists

$type
Projection
Sort
group by
aggregate operators

Update and delete 
select * from employee where salary is null;
{salary:{$type:10}}
Mongodb
Relational operators
Logical operators
between 1000 and 5000 -- comma 
$exists

$type
Projection
Sort
group by
aggregate operators

Update and delete 
select * from employee where salary is null;
{salary:{$type:10}}

+ ? *
/go+d/
? -- 0 or 1 char
* -- 0 or more characters
+ -- 1 or more characters
/go?d/
Matching : gd; god; Not matching : good

/go*d/
Matching : gd; god;, good; goooooooooooooood Not matching : gouod
  
/go+d/
Matching : god;, good; goooooooooooooood Not matching : gouod,gd

{empName:/^g/i}
{empName:/^g[a-z]*av$/i}
{empName:{$regex:/^g[a-z]*av$/i}}

Array operators
$elemMatch, $all, $size

db.students.insertMany([
{  studentId:101,marks:[10,20,30]},
  {  studentId:102,marks:[20,10,30]},
  {  studentId:103,marks:[10,70,30]},
  {  studentId:104,marks:[60,75,80]},
  {  studentId:105,marks:[90,90,90]},
  {  studentId:106,marks:[30,20,10]},
  
  ])

Docs which have the marks [10,20,30] -- exact search -- order of elements should be same
//101
{marks:[10,20,30]}

{studentId :{$in :[101,103,105]}}; // check if the studentId is one of the values in the list

Docs which have the marks [10,20,30] -- order of elements can vary -- $all
$all -- sub array -- position doesnt matter

{marks:{$all:[10,20,30]}};//101,102,106
{marks:{$all:[10]}};//101,102,106,103

$elemMatch
	-- works with array
	-- same element to match both the conditions or multiple conditions

Docs which have a mark between 50 and 62
//104
{marks:{$gt:50,$lt:62}}

Arrays : comma operator:
One element can match one condition and another element can match another condition

{marks:{$elemMatch:{$gt:50,$lt:62}}}

Projection operators
-- second parameter in find function
-- optional object
-- Exclusion list or inclusion list
db.zipcode.find({state:"MA"},{state:1,pop:1});//projected fields : state, pop, _id

db.zipcode.find({state:"MA"},{state:1,pop:1,_id:0});//projected fields : state, pop

db.zipcode.find({state:"MA"},{state:0});//projected fields : _id, city,loc,pop

db.zipcode.find({state:"MA"},{state:1,pop:0});//error

db.zipcode.find({},{state:1,pop:1,city:1});// all documents ; projected fields : state,city,pop

db.zipcode.find({},{});// all documents ; projected fields : all 

Update operations:
  -- update an existing docs
  -- updateOne
  -- updateMany
update emp set empName="ram" where empName="sara"

db.employee.updateOne(whereconditionDoc, updateDoc);
db.employee.updateOne({empName:"sara"},{$set:{empName:"ram"}});

db.employee.updateOne({empName:""},{$set:{empName:"ram"}});
  
db.employee.updateOne({empName:"Asha"},{$set:{empName:"ram"}})
Result:{matchedCount:1, modifiedCount:1}

db.employee.updateOne({empName:"Asha"},{$set:{empName:"ram"}})
Result:{matchedCount:0, modifiedCount:0}

db.employee.updateOne({empId:101},{$set:{empName:"ram"}})
Result:{matchedCount:1, modifiedCount:0}

db.employee.updateOne({empName:/av$/},{$set:{empName:"shyam"}})
Result:{matchedCount:1, modifiedCount:1}

Is this combination possible:
Result:{matchedCount:0, modifiedCount:1} -- No


$set:
	-- Set a value for an existing field(s)
	-- Add a new field

db.employee.updateOne({empName:/av$/},{$set:{empName:"shyam",salary:1000}})
db.employee.updateOne({empName:/av$/},{$set:{projectId:"p1"}})

$unset
	-- Remove an existing field
db.employee.updateOne({empId:101},{$unset:{empName:1}})


$inc :
update employee set salary=salary+1000 where empId=101
db.employee.updateOne({empId:101},{$inc:{salary:1000}})


update employee set salary=salary-1000 where empId=101
db.employee.updateOne({empId:101},{$inc:{salary:-1000}})

Replace an existing doc
db.employee.replaceOne({empId:101},{empId:999,empName:"tara",salary:8908})

Upsert : 
  -- update or insert
db.employee.updateOne({empId:909},{$set:{projectId:"p1"}})
Result:{matchedCount:0, modifiedCount:0} 

db.employee.updateOne({empId:909},{$set:{projectId:"p1"}},{upsert:true});// try an update; if not possible do an insertion
Result:{matchedCount:0, modifiedCount:0, upsertedCount:1,insertedId: } 
Inserted doc : {_id: autogenerated, empId:909,projectid:"p1"}

db.employee.updateOne({empId:909},{$set:{projectId:"p1"}},{upsert:true});// try an update; if not possible do an insertion
Result:{matchedCount:1, modifiedCount:0, upsertedCount:0} 

db.employee.updateOne({empId:{$gt:100}},{$set:{projectId:"p4"}},{upsert:true});// try an update; if not possible do an insertion
Result:{matchedCount:1, modifiedCount:1, upsertedCount:0}

db.employee.updateMany({empId:101},{$set:{salary:0}})
Result:{matchedCount:1, modifiedCount:1}

db.employee.updateMany({empId:101798},{$set:{salary:0}})
Result:{matchedCount:0, modifiedCount:0}

db.employee.updateMany({empId:{$in:[102,104,106]}},{$set:{salary:0}})
Result:{matchedCount:3, modifiedCount:3}

db.employee.updateMany({empId:{$in:[102,103,105]}},{$set:{salary:0}});// salaryof 102 is zero already
Result:{matchedCount:3, modifiedCount:2}

db.employee.updateMany({},{$set:{salary:100000}});// 
Result:{matchedCount:all the docs, modifiedCount:number of docs its modifying}

db.employee.updateMany({empId:101798},{$set:{salary:0}},{upsert:true})

Delete operations:
	-- delete document(s)
	-- deleteOne, deleteMany

db.employee.deleteOne(whereconditionObj)
db.emplyee.deleteMany(whereconditionObj)

db.employee.deleteOne({empId:101})

select max(salary) from employee
select max(salary) from employee where empId >101
select max(salary) from employee where empName like "a%" groupby deptId
select max(salary) from employee where empName like "a%" groupby deptId having sum(salary)>10000
select avg(salary) from employee

sort
db.employee.find().sort({salary:1})
db.employee.find().sort({salary:-1})
db.employee.find().sort({salary:1,empName:1})
db.employee.find().sort({salary:1,empName:-1})

select max(salary) from employee
db.employee.find().sort({salary:-1}).limit(1)


select sum(pop) as "SumOfPOP" from zipcode
select sum(pop) from zipcode groupby state
1. from zipcode 
2. group by state
3. sum(pop) of each group

db.zipcode.aggregate([
{
	$group:
		{
			_id:"$state",
			"SumOfPOP":{$sum:"$pop"}
		}	
},
{
	$project:
		{
			_id:0,
			"SumOfPOP":1,
			"state":"$_id"
		}
}
])

select count(*) as CountOfDocs,state from zipcode groupby state;
1. group by state
2. count the number of records in each group

Connection string: mongodb://localhost:27017/

import { MongoClient } from 'mongodb';

/*
 * Requires the MongoDB Node.js Driver
 * https://mongodb.github.io/node-mongodb-native
 */

const agg = [
  {
    '$group': {
      '_id': '$state', 
      'SumOfPop': {
        '$sum': '$pop'
      }, 
      'AvgPop': {
        '$avg': '$pop'
      }, 
      'CountOfDocs': {
        '$sum': 1
      }
    }
  }, {
    '$project': {
      'SumOfPop': 1, 
      'AvgPop': 1, 
      '_id': 0, 
      'state': '$_id', 
      'CountOfDocs': 1
    }
  }
];

const client = await MongoClient.connect(
  'mongodb://localhost:27017/'
);
const coll = client.db('marshDb').collection('zipcode');
const cursor = coll.aggregate(agg);
const result = await cursor.toArray();
await client.close();
















 









 

	









































+ ? *
/go+d/
? -- 0 or 1 char
* -- 0 or more characters
+ -- 1 or more characters
/go?d/
Matching : gd; god; Not matching : good

/go*d/
Matching : gd; god;, good; goooooooooooooood Not matching : gouod
  
/go+d/
Matching : god;, good; goooooooooooooood Not matching : gouod,gd

{empName:/^g/i}
{empName:/^g[a-z]*av$/i}
{empName:{$regex:/^g[a-z]*av$/i}}

Array operators
$elemMatch, $all, $size

db.students.insertMany([
{  studentId:101,marks:[10,20,30]},
  {  studentId:102,marks:[20,10,30]},
  {  studentId:103,marks:[10,70,30]},
  {  studentId:104,marks:[60,75,80]},
  {  studentId:105,marks:[90,90,90]},
  {  studentId:106,marks:[30,20,10]},
  
  ])

Docs which have the marks [10,20,30] -- exact search -- order of elements should be same
//101
{marks:[10,20,30]}

{studentId :{$in :[101,103,105]}}; // check if the studentId is one of the values in the list

Docs which have the marks [10,20,30] -- order of elements can vary -- $all
$all -- sub array -- position doesnt matter

{marks:{$all:[10,20,30]}};//101,102,106
{marks:{$all:[10]}};//101,102,106,103

$elemMatch
	-- works with array
	-- same element to match both the conditions or multiple conditions

Docs which have a mark between 50 and 62
//104
{marks:{$gt:50,$lt:62}}

Arrays : comma operator:
One element can match one condition and another element can match another condition

{marks:{$elemMatch:{$gt:50,$lt:62}}}

Projection operators
-- second parameter in find function
-- optional object
-- Exclusion list or inclusion list
db.zipcode.find({state:"MA"},{state:1,pop:1});//projected fields : state, pop, _id

db.zipcode.find({state:"MA"},{state:1,pop:1,_id:0});//projected fields : state, pop

db.zipcode.find({state:"MA"},{state:0});//projected fields : _id, city,loc,pop

db.zipcode.find({state:"MA"},{state:1,pop:0});//error

db.zipcode.find({},{state:1,pop:1,city:1});// all documents ; projected fields : state,city,pop

db.zipcode.find({},{});// all documents ; projected fields : all 

Update operations:
  -- update an existing docs
  -- updateOne
  -- updateMany
update emp set empName="ram" where empName="sara"

db.employee.updateOne(whereconditionDoc, updateDoc);
db.employee.updateOne({empName:"sara"},{$set:{empName:"ram"}});

db.employee.updateOne({empName:""},{$set:{empName:"ram"}});
  
db.employee.updateOne({empName:"Asha"},{$set:{empName:"ram"}})
Result:{matchedCount:1, modifiedCount:1}

db.employee.updateOne({empName:"Asha"},{$set:{empName:"ram"}})
Result:{matchedCount:0, modifiedCount:0}

db.employee.updateOne({empId:101},{$set:{empName:"ram"}})
Result:{matchedCount:1, modifiedCount:0}

db.employee.updateOne({empName:/av$/},{$set:{empName:"shyam"}})
Result:{matchedCount:1, modifiedCount:1}

Is this combination possible:
Result:{matchedCount:0, modifiedCount:1} -- No


$set:
	-- Set a value for an existing field(s)
	-- Add a new field

db.employee.updateOne({empName:/av$/},{$set:{empName:"shyam",salary:1000}})
db.employee.updateOne({empName:/av$/},{$set:{projectId:"p1"}})

$unset
	-- Remove an existing field
db.employee.updateOne({empId:101},{$unset:{empName:1}})


$inc :
update employee set salary=salary+1000 where empId=101
db.employee.updateOne({empId:101},{$inc:{salary:1000}})


update employee set salary=salary-1000 where empId=101
db.employee.updateOne({empId:101},{$inc:{salary:-1000}})

Replace an existing doc
db.employee.replaceOne({empId:101},{empId:999,empName:"tara",salary:8908})

Upsert : 
  -- update or insert
db.employee.updateOne({empId:909},{$set:{projectId:"p1"}})
Result:{matchedCount:0, modifiedCount:0} 

db.employee.updateOne({empId:909},{$set:{projectId:"p1"}},{upsert:true});// try an update; if not possible do an insertion
Result:{matchedCount:0, modifiedCount:0, upsertedCount:1,insertedId: } 
Inserted doc : {_id: autogenerated, empId:909,projectid:"p1"}

db.employee.updateOne({empId:909},{$set:{projectId:"p1"}},{upsert:true});// try an update; if not possible do an insertion
Result:{matchedCount:1, modifiedCount:0, upsertedCount:0} 

db.employee.updateOne({empId:{$gt:100}},{$set:{projectId:"p4"}},{upsert:true});// try an update; if not possible do an insertion
Result:{matchedCount:1, modifiedCount:1, upsertedCount:0}

db.employee.updateMany({empId:101},{$set:{salary:0}})
Result:{matchedCount:1, modifiedCount:1}

db.employee.updateMany({empId:101798},{$set:{salary:0}})
Result:{matchedCount:0, modifiedCount:0}

db.employee.updateMany({empId:{$in:[102,104,106]}},{$set:{salary:0}})
Result:{matchedCount:3, modifiedCount:3}

db.employee.updateMany({empId:{$in:[102,103,105]}},{$set:{salary:0}});// salaryof 102 is zero already
Result:{matchedCount:3, modifiedCount:2}

db.employee.updateMany({},{$set:{salary:100000}});// 
Result:{matchedCount:all the docs, modifiedCount:number of docs its modifying}

db.employee.updateMany({empId:101798},{$set:{salary:0}},{upsert:true})

Delete operations:
	-- delete document(s)
	-- deleteOne, deleteMany

db.employee.deleteOne(whereconditionObj)
db.emplyee.deleteMany(whereconditionObj)

db.employee.deleteOne({empId:101})








 

	








































